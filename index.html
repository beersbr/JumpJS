<html>
<head>
<style type="text/css">

</style>
<script type="text/javascript" src="scripts/common.js"></script>
<script type="text/javascript" src="scripts/keyboard.js"></script>
<script type="text/javascript" src="scripts/vector.js"></script>
<script type="text/javascript" src="scripts/list.js"></script>
<script type="text/javascript">

/** Entity Base class */
function Entity(args)
{
    if(args == undefined) args = {};

    this._x = args.x || 0;
    this._y = args.y || 0;
    this.w = args.w || 0;
    this.h = args.h || 0;

    // half width and height
    this.hw = this.w/2;
    this.hh = this.h/2;

    this._cx = this._x + this.w/2;
    this._cy = this._y + this.h/2;

    this.ax = args.ax || 0;
    this.ay = args.ay || 0;

    Object.defineProperty(this, "x", {
        get: function(){
            return this._x;
        },
        set: function(v){
            this._x = v;
        }
    });

    Object.defineProperty(this, "y", {
        get: function(){
            return this._y;
        },
        set: function(v){
            this._y = v;
        }
    });

    Object.defineProperty(this, "cx", {
        get: function(){
            return this._cx;
        },
        set: function(v){
            this._cx = v;
            this._x = this._cx - this.w/2;
        }
    });

    Object.defineProperty(this, "cy", {
        get: function(){
            return this._cy;
        },
        set: function(v){
            this._cy = v;
            this._y = this._cy - this.h/2;
        }
    });

    /** Needed functions */

    this.Draw = function(ctx)
    {
        return true;
    }

    this.Update = function(elapsed_time)
    {
        return true;
    }

    /** Collision checks */
    Entity.collisionAABB = function(e1, e2)
    {
        if(e1.x > e2.x+e2.w) return false;
        if(e1.x+e1.w < e2.x) return false;
        if(e1.y > e2.y+e2.h) return false;
        if(e1.y+e1.w < e2.y) return false;

        return true;
    }

    /** returns collision target */
    Entity.collidesWithAABB = function(entity)
    {
        var target = [];
        Entity.entities.eachValue(function(e){
            if(entity == e) return false;
            if(Entity.collisionAABB(entity, e))
               target.push(e);
        });
        return target;
    }

    if(Entity.entities == undefined)
        Entity.entities = new List.List();

    var e = (args.ext) ? args.ext : this;
    Entity.entities.push(e);
}


/** Class Block */
function Block(args)
{
    if(args == undefined) args = {};

    args.ext = this;
    Extend(this, Entity, args);

    this.color = new Color(Math.randomInt(100, 200), Math.randomInt(100, 200), Math.randomInt(100, 200));

    this.Draw = function(ctx)
    {
        ctx.save();
        ctx.fillStyle = this.color.toString();
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.restore();
    }

    this.Update = function()
    {
        return true;
    }
}

function Player(args)
{
    if(args == undefined) args = {};

    args.x = 35;
    args.y = 35;
    args.w = 35;
    args.h = 50;

    args.ext = this;
    Extend(this, Entity, args);

    this.jumping = false;
    this.attatched = false;

    this.gravity = 0.65;

    this.color = new Color(230, 230, 230);

    this.Draw = function(ctx)
    {
        ctx.save();
        ctx.fillStyle = this.color.toString();
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.restore();
    }

    this.Update = function(time_delta, keyboard)
    {

        // jump
        if(keyboard.keyIsDown('w') || keyboard.keyIsDown('up_arrow'))
        {
            this.jumping = true;

        }
        if(keyboard.keyIsDown('a') || keyboard.keyIsDown('left_arrow'))
        {
            this.ax -= 0.9;
        }
        if(keyboard.keyIsDown('s') || keyboard.keyIsDown('down_arrow'))
        {

        }
        if(keyboard.keyIsDown('d') || keyboard.keyIsDown('right_arrow'))
        {
            this.ax += 0.9;
        }


        // do all the calculations
        this.ay += (this.jumping || !this.attatched) ? this.gravity : 0.0;

        // check for collision and then make the final moves
        var targets = Entity.collidesWithAABB(this);
        for(var idx in targets)
        {
            var target = targets[idx];

            // get my orientation with respect to the target
            var minimum_x_space = this.hw + target.hw;
            var mininum_y_space = this.hh + target.hh;
//            var actual_x_space = this.

        }

        this.x += this.ax;
        this.y += this.ay;
    }
}

/** Game Stuff */
Game = {};

/** states */
States = {
    LOADING: 0,
    PLAYING: 1,
    PAUSED: 2,
    SETUP: 3
}

Game.current_time = 0.0;
Game.last_time = 0.0;

Game.setup = function(time_delta)
{
    Game.blocks = new List.List();

    // create the ground block
    var ground = new Block({
        x: 0,
        y: 550,
        w: 800,
        h: 60
    });

    Game.player = new Player();

    Game.blocks.push(ground);
}

Game.loading_state = function(time_delta)
{
    console.log("loading");

    // if we are done loading...
    Game.setup(time_delta);
    Game.state = States.PLAYING;

}

Game.playing_state = function(time_delta, keyboard)
{
    //draw and update each entity
    Entity.entities.eachValue(function(e){
        e.Draw(Game.canvas.context);
        e.Update(time_delta, keyboard);
    });
}

Game.loop = function()
{
    Game.last_time = Game.current_time;
    Game.current_time = +new Date();
    var delta_time = Game.current_time - Game.last_time;

    Game.canvas.context.clearRect(0, 0, 800, 600);

    switch(Game.state)
    {
        case States.LOADING:
            Game.loading_state(delta_time);
            break;
        case States.PAUSED:
            break;
        case States.PLAYING:
            Game.playing_state(delta_time, Game.keyboard);
            break;
    }

    requestAnimFrame(Game.loop);
}

window.onload = function()
{
    Game.canvas = new Canvas();
    Game.keyboard = new KeyboardHandler();

    Game.state = States.LOADING;
    Game.loop();
}

</script>
</head>
<body>
    <div class="game-canvas" id="canvas"></div>
</body>
</html>
